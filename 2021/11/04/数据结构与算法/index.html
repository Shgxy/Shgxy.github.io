<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="ifDo7"><meta name="copyright" content="ifDo7"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>数据结构与算法 | ifDo7's Blog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_j5gk85dg4pf.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"shgxy.github.io.git","root":"/","title":"可那灯火未明的不老阁","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["255, 0, 0","0, 255, 0","0, 255, 255"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="ifDo7's Blog" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="🔴复杂度分析时间复杂度 T(n) &#x3D; O( f(n) )   T(n) ：表示代码执行的时间；  n ：表示数据规模的大小；  f(n) ：表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。  O ：表示代码的执行时间 T(n) 与 f(n) 表达式成正比。   大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="ifDo7&#39;s Blog">
<meta property="og:description" content="🔴复杂度分析时间复杂度 T(n) &#x3D; O( f(n) )   T(n) ：表示代码执行的时间；  n ：表示数据规模的大小；  f(n) ：表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。  O ：表示代码的执行时间 T(n) 与 f(n) 表达式成正比。   大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211104172037684.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211106140055670.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211106160213578.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211106160704590.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211106162233492.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211106164403506.png">
<meta property="og:image" content="d:/blog/shgxyBlog/source_posts/数据结构与算法/image-20211107195658438.png">
<meta property="og:image" content="d:/blog/shgxyBlog/source/_posts/数据结构与算法/image-20211107225507064.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211109193834301.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211109202446866.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211109213614262.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/641.gif">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/640.gif">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211109221015008.png">
<meta property="og:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/642.gif">
<meta property="article:published_time" content="2021-11-04T07:27:00.000Z">
<meta property="article:modified_time" content="2021-11-09T14:18:06.405Z">
<meta property="article:author" content="ifDo7">
<meta property="article:tag" content="notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20211104172037684.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="ifDo7"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="ifDo7"><span class="site-author-status" title="维纳斯的银钩。">🥱</span></a><div class="site-author-name"><a href="/about/">ifDo7</a></div><span class="site-name">ifDo7's Blog</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">20</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">18</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">15</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" title="QQ群:待定ing" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" title="微信:shg799" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/Shgxy" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:shg799@foxmail.com" title="E-Mail:shg799@foxmail.com" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/" title="共产主义接班人" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">🔴复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">时间复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">几种常见时间复杂度实例分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-1"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">O(1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-logn-%E3%80%81O-nlogn"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">O(logn)、O(nlogn)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-m-n-%E3%80%81O-m-n"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">O(m+n)、O(m*n)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">空间复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">下标从0开始？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-ArrayList"><span class="toc-number">2.2.</span> <span class="toc-text">Java ArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">2.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">LRU 缓存淘汰算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">链表结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0-LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">如何基于链表实现 LRU 缓存淘汰算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">3.4.</span> <span class="toc-text">写链表代码的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">3.4.1.</span> <span class="toc-text">理解指针或引用的含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AD%A6%E6%83%95%E6%8C%87%E9%92%88%E4%B8%A2%E5%A4%B1%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">警惕指针丢失和内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%93%A8%E5%85%B5%E7%AE%80%E5%8C%96%E5%AE%9E%E7%8E%B0%E9%9A%BE%E5%BA%A6"><span class="toc-number">3.4.3.</span> <span class="toc-text">利用哨兵简化实现难度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E7%95%99%E6%84%8F%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">3.4.4.</span> <span class="toc-text">重点留意边界条件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E7%94%BB%E5%9B%BE%EF%BC%8C%E8%BE%85%E5%8A%A9%E6%80%9D%E8%80%83"><span class="toc-number">3.4.5.</span> <span class="toc-text">举例画图，辅助思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%86%99%E5%A4%9A%E7%BB%83"><span class="toc-number">3.4.6.</span> <span class="toc-text">多写多练</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#other"><span class="toc-number">3.5.</span> <span class="toc-text">other</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="toc-number">3.5.1.</span> <span class="toc-text">头节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E5%85%83%E8%8A%82%E7%82%B9"><span class="toc-number">3.5.2.</span> <span class="toc-text">首元节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%8C%87%E9%92%88"><span class="toc-number">3.5.3.</span> <span class="toc-text">头指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">4.1.</span> <span class="toc-text">支持动态扩容的顺序栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">6.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">7.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">冒泡排序（Bubble Sort）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion-Sort%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">插入排序（Insertion Sort）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection-Sort%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">选择排序（Selection Sort）</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://Shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="ifDo7"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="ifDo7's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据结构与算法</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-11-04 15:27:00" itemprop="dateCreated datePublished" datetime="2021-11-04T15:27:00+08:00">2021-11-04</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-11-09 22:18:06" itemprop="dateModified" datetime="2021-11-09T22:18:06+08:00">2021-11-09</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Data/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Data</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/notes/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">notes</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="🔴复杂度分析"><a href="#🔴复杂度分析" class="headerlink" title="🔴复杂度分析"></a>🔴<strong>复杂度分析</strong></h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><blockquote>
<p>T(n) = O( f(n) )</p>
</blockquote>
<ul>
<li><p>T(n) ：表示代码执行的时间；</p>
</li>
<li><p>n ：表示数据规模的大小；</p>
</li>
<li><p>f(n) ：表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。</p>
</li>
<li><p>O ：表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
</li>
</ul>
<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>💡<strong>只关注循环执行次数最多的一段代码</strong></p>
<p>💡<strong>加法法则：总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong></p>
<ul>
<li>如果 T1(n)=O( f(n) )，T2(n)=O( g(n) )；</li>
<li>那么 T(n)=T1(n)+T2(n)=max{ O( f(n) ), O( g(n) ) } = O( max( f(n), g(n) ) ).</li>
</ul>
<p>💡<strong>乘法法则：嵌套代码 的复杂度等于嵌套 内外 代码复杂度的 乘积</strong></p>
<ul>
<li>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；</li>
<li>那么 T(n)=T1(n)·T2(n)=O(f(n))·O(g(n))=O(f(n)·g(n)).</li>
</ul>
<h4 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h4><h4 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a><strong>O(1)</strong></h4><p>**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。</p>
<h4 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a><strong>O(logn)、O(nlogn)</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">i&#x3D;1;
while (i &lt;&#x3D; n)  &#123;
  i &#x3D; i * 2;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p>
<ul>
<li><p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。</p>
</li>
<li><p>得到：2^x=n</p>
</li>
<li><p>求得：x=log2(n)</p>
</li>
<li><p>所以，这段代码的时间复杂度就是 O(log2(n))。</p>
</li>
</ul>
<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 **O(logn)**。</p>
<p>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 <strong>O(nlogn)</strong> 了</p>
<h4 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a><strong>O(m+n)、O(m*n)</strong></h4><p>代码的复杂度<strong>由两个数据的规模</strong>来决定：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int cal(int m, int n) &#123;
  int sum_1 &#x3D; 0;
  int i &#x3D; 1;
  for (; i &lt; m; ++i) &#123;
    sum_1 &#x3D; sum_1 + i;
  &#125;
 
  int sum_2 &#x3D; 0;
  int j &#x3D; 1;
  for (; j &lt; n; ++j) &#123;
    sum_2 &#x3D; sum_2 + j;
  &#125;
 
  return sum_1 + sum_2;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于无法事先评估 m 和 n 谁的量级大，所以不能简单地利用加法法则，省略掉其中一个。上面代码的时间复杂度表示为： **O(m+n)**。</p>
<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
 
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    print out a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第 2 行代码中，申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 **O(n)**。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。</p>
<p>常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。</p>
<p><img src="./image-20211104172037684.png" alt="image-20211104172037684"></p>
<p>浅析最好、最坏、平均、均摊时间复杂度。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote>
<p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>
</blockquote>
<ul>
<li><p><strong>线性表</strong>（Linear List）</p>
<ul>
<li>线性表就是数据排成像一条线一样的结构。</li>
<li>每个线性表上的数据最多只有前和后两个方向。</li>
<li>除了数组，链表、队列、栈等也是线性表结构。</li>
</ul>
</li>
<li><p><strong>连续的内存空间和相同类型的数据</strong></p>
</li>
</ul>
<p>因为这两个限制，它有了一个堪称“杀手锏”的特性：<strong>“随机访问”</strong>。</p>
<p>但这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
<h2 id="下标从0开始？"><a href="#下标从0开始？" class="headerlink" title="下标从0开始？"></a>下标从0开始？</h2><p>当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">a[i]_address &#x3D; base_address + i * data_type_size
    &#x2F;&#x2F;其中 data_type_size 表示数组中每个元素的大小;
    &#x2F;&#x2F;内存块的首地址为 base_address。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[i] 就表示偏移 i 个 data_type_size 的位置。</p>
<p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">a[k]_address &#x3D; base_address + (k-1)*type_size<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>每次随机访问数组元素都多了一次<strong>减法运算</strong>，对于 CPU 来说，就是多了一次减法指令。</p>
<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了<strong>减少一次减法操作</strong>，数组选择了<strong>从 0 开始</strong>编号，而不是从 1 开始。</p>
<h2 id="Java-ArrayList"><a href="#Java-ArrayList" class="headerlink" title="Java ArrayList"></a>Java ArrayList</h2><blockquote>
<p>ArrayList 类是一个可以<strong>动态修改</strong>的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。</p>
<p>ArrayList 继承了 AbstractList ，并实现了 List 接口。</p>
</blockquote>
<p>ArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span><span class="token punctuation">;</span> <span class="token comment">// 引入 ArrayList 类</span>

<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> objectName <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　 <span class="token comment">// 初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>E</strong>: 泛型数据类型，用于设置 objectName 的数据类型，<strong>只能为引用数据类型</strong>。</li>
<li><strong>objectName</strong>: 对象名。</li>
</ul>
<p>如果我们要存储其他类型，而 &lt;E&gt; 只能为引用数据类型，这时我们就需要使用到基本类型的包装类。</p>
<p>基本类型对应的包装类表如下：</p>
<table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">引用类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
</tbody></table>
<p>Java ArrayList 常用方法列表如下：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-add.html">add()</a></td>
<td align="left">将元素插入到指定位置的 arraylist 中</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-addall.html">addAll()</a></td>
<td align="left">添加集合中的所有元素到 arraylist 中</td>
</tr>
<tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-clear.html">clear()</a></td>
<td align="left">删除 arraylist 中的所有元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-clone.html">clone()</a></td>
<td align="left">复制一份 arraylist</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-contains.html">contains()</a></td>
<td align="left">判断元素是否在 arraylist</td>
</tr>
<tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-get.html">get()</a></td>
<td align="left">通过索引值获取 arraylist 中的元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-indexof.html">indexOf()</a></td>
<td align="left">返回 arraylist 中元素的索引值</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-removeall.html">removeAll()</a></td>
<td align="left">删除存在于指定集合中的 arraylist 里的所有元素</td>
</tr>
<tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-remove.html">remove()</a></td>
<td align="left">删除 arraylist 里的单个元素</td>
</tr>
<tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-size.html">size()</a></td>
<td align="left">返回 arraylist 里元素数量</td>
</tr>
<tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-isempty.html">isEmpty()</a></td>
<td align="left">判断 arraylist 是否为空</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-sublist.html">subList()</a></td>
<td align="left">截取部分 arraylist 的元素</td>
</tr>
<tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-set.html">set()</a></td>
<td align="left">替换 arraylist 中指定索引的元素</td>
</tr>
<tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-sort.html">sort()</a></td>
<td align="left">对 arraylist 元素进行排序</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-toarray.html">toArray()</a></td>
<td align="left">将 arraylist 转换为数组</td>
</tr>
<tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-tostring.html">toString()</a></td>
<td align="left">将 arraylist 转换为字符串</td>
</tr>
<tr>
<td align="left">🔴<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-foreach.html">forEach()</a></td>
<td align="left">遍历 arraylist 中每一个元素并执行特定操作</td>
</tr>
</tbody></table>
<p>💡有些时候，用数组会更合适些：</p>
<ul>
<li><p>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组；</p>
</li>
<li><p>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</p>
</li>
<li><p>当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList&gt; array。</p>
</li>
</ul>
<p>总结：对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>数组可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h2><blockquote>
<p>常见的三种缓存淘汰策略：</p>
<p>先进先出策略         FIFO（First In，First Out）</p>
<p>最少使用策略         LFU（Least Frequently Used）</p>
<p>最近最少使用策略 LRU（Least Recently Used）</p>
</blockquote>
<h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><blockquote>
<p>链表不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用。</p>
</blockquote>
<p>三种最常见的链表结构：</p>
<ul>
<li>单链表</li>
<li>双向链表</li>
<li>循环链表</li>
</ul>
<p>我们把内存块称为链表的“<strong>结点</strong>”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>。</p>
<p><img src="./image-20211106140055670.png" alt="image-20211106140055670"></p>
<p>我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。</p>
<ul>
<li><p>头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。</p>
</li>
<li><p>尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 NULL</strong>，表示这是链表上最后一个结点。</p>
</li>
</ul>
<br>

<p>从下图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p>
<p><img src="./image-20211106160213578.png" alt="image-20211106160213578"></p>
<p>链表需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。所以链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p>
<br>

<p><img src="./image-20211106160704590.png" alt="image-20211106160704590"></p>
<p><strong>循环链表是一种特殊的单链表</strong>。它跟单链表唯一的区别就在尾结点。循环链表的尾结点指针是指向链表的头结点。</p>
<p>优点：</p>
<ul>
<li>从链尾到链头比较方便。</li>
<li>当要处理的数据具有<strong>环型结构</strong>特点时，就特别适合采用循环链表。<ul>
<li>比如著名的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">约瑟夫问题</a>。</li>
</ul>
</li>
</ul>
<br>

<p><img src="./image-20211106162233492.png" alt="image-20211106162233492"></p>
<p><strong>双向链表</strong>：支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<p>虽然两个指针比较浪费存储空间，但可以支持<strong>双向遍历</strong>，这样也带来了双向链表操作的灵活性。</p>
<p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点。双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p>
<br>

<p>在实际的软件开发中，从链表中<strong>删除一个数据</strong>无外乎这两种情况：</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点；</li>
<li>删除给定指针指向的结点。</li>
</ul>
<p><strong>对于第一种情况</strong>，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，删除之。</p>
<ul>
<li>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</li>
</ul>
<p><strong>对于第二种情况</strong>，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</p>
<ul>
<li>对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</li>
<li>如果想在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。</li>
</ul>
<p>Java LinkedHashMap 的实现原理，就用到了双向链表这种数据结构。</p>
<p>把这两种链表整合在一起：<strong>双向循环链表</strong>。</p>
<p><img src="./image-20211106164403506.png" alt="image-20211106164403506"></p>
<h2 id="如何基于链表实现-LRU-缓存淘汰算法？"><a href="#如何基于链表实现-LRU-缓存淘汰算法？" class="headerlink" title="如何基于链表实现 LRU 缓存淘汰算法？"></a>如何基于链表实现 LRU 缓存淘汰算法？</h2><p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p>
<ul>
<li><p>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p>
</li>
<li><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p>
<ul>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ul>
</li>
</ul>
<h2 id="写链表代码的技巧"><a href="#写链表代码的技巧" class="headerlink" title="写链表代码的技巧"></a><strong>写链表代码的技巧</strong></h2><h3 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h3><div class="success">

<blockquote>
<p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p>
</blockquote>
</div>

<p>在编写链表代码的时候，我们经常会有这样的代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">	p-&gt;next &#x3D; q
&#x2F;&#x2F;	这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>还有一个更复杂的，也是写链表代码经常会用到的：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">	p-&gt;next &#x3D; p-&gt;next-&gt;next
&#x2F;&#x2F;	这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="警惕指针丢失和内存泄漏"><a href="#警惕指针丢失和内存泄漏" class="headerlink" title="警惕指针丢失和内存泄漏"></a>警惕指针丢失和内存泄漏</h3><p>C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。</p>
<p>所以，我们<strong>插入结点时，一定要注意操作的顺序</strong>，要先将待插入结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。</p>
<pre class="line-numbers language-none"><code class="language-none">x-&gt;next &#x3D; p-&gt;next;  &#x2F;&#x2F; 将 x 的结点的 next 指针指向 b 结点；
p-&gt;next &#x3D; x;  &#x2F;&#x2F; 将 p 的 next 指针指向 x 结点；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>删除链表结点时，也一定要记得手动释放内存空间</strong>。</p>
<p>当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。</p>
<h3 id="利用哨兵简化实现难度"><a href="#利用哨兵简化实现难度" class="headerlink" title="利用哨兵简化实现难度"></a>利用哨兵简化实现难度</h3><blockquote>
<p><strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</strong>。</p>
</blockquote>
<p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫<strong>带头链表</strong>。相反，没有哨兵结点的链表就叫作<strong>不带头链表</strong>。</p>
<p><img src="D:\blog\shgxyBlog\source_posts\数据结构与算法\image-20211107195658438.png" alt="image-20211107195658438"></p>
<h3 id="重点留意边界条件处理"><a href="#重点留意边界条件处理" class="headerlink" title="重点留意边界条件处理"></a>重点留意边界条件处理</h3><p>检查链表代码是否正确的<strong>边界条件</strong>：</p>
<ul>
<li>如果链表为空时，代码是否能正常工作？</li>
<li>如果链表只包含一个结点时，代码是否能正常工作？</li>
<li>如果链表只包含两个结点时，代码是否能正常工作？</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li>
</ul>
<h3 id="举例画图，辅助思考"><a href="#举例画图，辅助思考" class="headerlink" title="举例画图，辅助思考"></a>举例画图，辅助思考</h3><h3 id="多写多练"><a href="#多写多练" class="headerlink" title="多写多练"></a>多写多练</h3><p>5 个常见的链表操作：</p>
<ul>
<li>单链表反转 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/">乐扣206</a><ul>
<li>原理图：<ul>
<li><img src="D:\blog\shgxyBlog\source\_posts\数据结构与算法\image-20211107225507064.png" alt="image-20211107225507064" style="zoom: 40%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Definition for singly-linked list.
 * public class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode() &#123;&#125;
 *     ListNode(int val) &#123; this.val = val; &#125;
 *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
 * &#125;
 */</span>
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">ListNode</span> newEle <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">ListNode</span> curr    <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">ListNode</span> nextEle <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> newEle<span class="token punctuation">;</span>
            newEle <span class="token operator">=</span> curr<span class="token punctuation">;</span>
            curr <span class="token operator">=</span> nextEle<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> newEle<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/**
输入
[1,2,3,4,5]
输出
[5,4,3,2,1]
预期结果
[5,4,3,2,1]
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>链表中环的检测 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">力扣141</a><ul>
<li>原理（快慢指针解法）<ul>
<li>快指针每次走2步，慢指针每次走1步。如果快指针已经走到了<code>NULL</code>，那自然不存在环，如果快指针遇到了慢指针，说明快慢指针都在环里兜圈，存在环。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Definition for singly-linked list.
 * class ListNode &#123;
 *     int val;
 *     ListNode next;
 *     ListNode(int x) &#123;
 *         val = x;
 *         next = null;
 *     &#125;
 * &#125;
 */</span>
<span class="token comment">//不正经解法</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">double</span> test <span class="token operator">=</span> <span class="token number">1e4</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>test <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            test<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//正统解法</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ListNode</span> h1 <span class="token operator">=</span> head<span class="token punctuation">,</span> h2 <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>h2 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h2<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            h1 <span class="token operator">=</span> h1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            h2 <span class="token operator">=</span> h2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>h1 <span class="token operator">==</span> h2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/**
输入
    [3,2,0,-4]
    1
输出
	true
预期结果
	true
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>两个有序的链表合并 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">力扣21</a><ul>
<li>原理（迭代法）<ul>
<li>当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> l1<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ListNode</span> preHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> preHead<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>
                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                pre<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>
                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> l2 <span class="token operator">:</span> l1<span class="token punctuation">;</span>
        <span class="token keyword">return</span> preHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/**
输入
    [1,2,4]
    [1,3,4]
输出
	[1,1,2,3,4,4]
预期结果
	[1,1,2,3,4,4]
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>删除链表倒数第 n 个结点 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">力扣19</a><ul>
<li>原理<ul>
<li>设定双指针 <code>p</code> 和 <code>q</code> ，当 <code>q</code> 指向末尾的 <code>NULL</code>，<code>p</code> 与 <code>q</code> 之间相隔的元素个数为 <code>n</code> 时，那么删除掉 <code>p</code> 的下一个指针就完成了要求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ListNode</span> index1 <span class="token operator">=</span> head<span class="token punctuation">,</span> index2 <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  index2 <span class="token operator">=</span> index2<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">//使得index1与index2之间间隔n-1个节点       </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>index2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>   <span class="token comment">//说明删除的是头节点</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>index2<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//将index2移至最后一个节点</span>
            index2 <span class="token operator">=</span> index2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            index1 <span class="token operator">=</span> index1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        index1<span class="token punctuation">.</span>next <span class="token operator">=</span> index1<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/**
输入
    [1,2,3,4,5]
    2
输出
	[1,2,3,5]
预期结果
	[1,2,3,5]
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>求链表的中间结点 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">力扣876</a><ul>
<li>原理<ul>
<li>对链表进行遍历，同时将遍历到的元素依次放入数组 <code>A</code> 中。如果我们遍历到了 <code>N</code> 个元素，那么链表以及数组的长度也为 <code>N</code>，对应的中间节点即为 <code>A[N/2]</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">middleNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">;</span>
            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="头节点"><a href="#头节点" class="headerlink" title="头节点"></a>头节点</h3><blockquote>
<p>有时，在链表的第一个节点之前会额外增设一个节点，该节点的数据域一般不存放数据（有些情况下也可以存放链表的长度等信息），此节点被称为头节点。</p>
</blockquote>
<p>若链表中存在头节点，且头节点的指针域为空（NULL），表明链表是空表。</p>
<p><strong>头节点对于链表来说，不是必须的，换句话说，一个完整的链表中可以不设有头节点。</strong></p>
<p>那么，可能有人会问：既然头节点无关紧要，那它有什么作用？在处理某些问题时，给链表添加头节点会使问题变得简单。</p>
<h3 id="首元节点"><a href="#首元节点" class="headerlink" title="首元节点"></a>首元节点</h3><p>链表中第一个元素所在的节点，它是头节点后边的第一个节点。</p>
<p>其实，首元节点和链表中存放数据的其他节点没什么不同，只是因为该节点位于链表的头部，所以被称为首元节点。</p>
<h3 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a>头指针</h3><p>链表的头指针永远指向链表中第一个节点的位置，换句话说，如果链表有头节点，头指针指向头节点；否则，头指针指向首元节点。</p>
<p>一个链表可以头节点，但不能没有头指针。<br>头节点和头指针的区别是：</p>
<ul>
<li>头指针是一个指针，头指针指向链表的头节点或者首元节点；</li>
<li>头节点是一个实际存在的节点，它包含有数据域和指针域。</li>
</ul>
<p>头节点和头指针的区别在程序中的直接体现是：头指针只声明而没有分配存储空间，头节点需要声明并分配一个节点的实际物理内存。</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h1><blockquote>
<p><strong>栈是一种“操作受限”的线性表</strong>；</p>
<p>当某个数据集合只涉及在一端插入和删除数据，并且满足 <strong>后进先出</strong>、<strong>先进后出</strong> 的特性，我们就应该首选“栈”这种数据结构。</p>
</blockquote>
<img src="./image-20211109193834301.png" alt="image-20211109193834301" style="zoom:50%;" />

<blockquote>
<p>用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>
</blockquote>
<p>顺序栈：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 基于数组实现的顺序栈</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayStack</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">private</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>  <span class="token comment">// 数组</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>       <span class="token comment">// 栈中元素个数</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>           <span class="token comment">// 栈的大小</span>
 
  <span class="token comment">// 初始化数组，申请一个大小为 n 的数组空间</span>
  <span class="token keyword">public</span> <span class="token class-name">ArrayStack</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
 
  <span class="token comment">// 入栈操作</span>
  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 数组空间不够了，直接返回 false，入栈失败。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 将 item 放到下标为 count 的位置，并且 count 加一</span>
    items<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
    <span class="token operator">++</span>count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token comment">// 出栈操作</span>
  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 栈为空，则直接返回 null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span>
    <span class="token class-name">String</span> tmp <span class="token operator">=</span> items<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">--</span>count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>链式栈：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkStack</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">Object</span> data<span class="token punctuation">;</span>
        <span class="token class-name">Node</span> next<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">,</span><span class="token class-name">Node</span> next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> top<span class="token punctuation">;</span>   <span class="token comment">//栈顶元素</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>   <span class="token comment">//当前栈的大小</span>

    <span class="token comment">/**
     * 创建空链栈
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        top <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 以data数据元素创建链式栈
     * @param data
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LinkStack</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        top <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 判断链栈是否为空栈
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> size <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 返回链栈的长度
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> size<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 压栈(入栈)
     * @param data
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

        <span class="token comment">//更新头节点</span>
<span class="token comment">//      System.out.print("压栈成功:" + data + "指向->" + top + "\t");</span>
        <span class="token comment">// 让top指向新创建的元素，新元素的next引用指向原来的栈顶元素</span>
        top <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 出栈
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"目前是空栈，无法进行出栈!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">"error!"</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token class-name">Node</span> temp <span class="token operator">=</span> top<span class="token punctuation">;</span>    
        <span class="token comment">// 更新头结点</span>
        top <span class="token operator">=</span> top<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment">// 释放原栈顶元素的next引用，删除指针指向</span>
        temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        size<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> temp<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 访问栈顶元素
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> top<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token string">"空栈，无栈顶元素!"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/**
     * 遍历栈并打印栈内元素
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">displayStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>top <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            top<span class="token operator">=</span>top<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">/**
     * 清空栈
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        top <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>wilson_m<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">80104424</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h2><img src="./image-20211109202446866.png" alt="image-20211109202446866" style="zoom:60%;" />

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h1><br>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h1><br>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h1><blockquote>
<p>最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。</p>
</blockquote>
<p><strong>排序算法的稳定性：</strong></p>
<blockquote>
<p>经过某种排序算法排序之后，</p>
<p>如果两个数据的前后顺序 没有改变，那我们就把这种排序算法叫作 <strong>稳定的排序算法</strong>；</p>
<p>如果前后顺序 发生变化，那对应的排序算法就叫作 <strong>不稳定的排序算法</strong>。</p>
</blockquote>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><blockquote>
<p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</p>
</blockquote>
<p>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n-1 次，就完成了 n 个数据的排序工作。</p>
<img src="./image-20211109213614262.png" alt="image-20211109213614262" style="zoom:50%;" />

<p>冒泡过程还可以优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 冒泡排序，a 表示数组，n 表示数组大小</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
 
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 提前退出冒泡循环的标志位</span>
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 交换</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 表示有数据交换      </span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 没有数据交换，提前退出</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>插入算法的<strong>核心思想</strong>：</p>
<blockquote>
<p>取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p>
</blockquote>
<img src="./641.gif" alt="图片" style="zoom:67%;" />

<img src="./640.gif" alt="图片" style="zoom:67%;" />

<p>具体算法描述如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在<strong>已排序的元素序列中</strong> 从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 插入排序，a 表示数组，n 表示数组大小</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
 	<span class="token keyword">int</span> value<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    value <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//取出下一个元素</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 查找插入的位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//已排序的元素序列中</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 数据移动</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span> 	  <span class="token comment">// 插入数据</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<img src="./image-20211109221015008.png" alt="image-20211109221015008" style="zoom:67%;" />

<p>具体算法描述如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>
<img src="./642.gif" alt="图片" style="zoom:67%;" />

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
           <span class="token keyword">return</span> array<span class="token punctuation">;</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
           <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//找到最小的数</span>
                   minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">//将最小数的索引保存</span>
           <span class="token punctuation">&#125;</span>
           <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
           array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
           array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
       <span class="token punctuation">&#125;</span>
       <span class="token keyword">return</span> array<span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>































































</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>ifDo7</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法">https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul><script>document.addEventListener('copy', function (event) {
  const clipboardData = event.clipboardData || window.clipboardData;
  if (!clipboardData) { return; }
  const text = window.getSelection().toString();
  if (text) {
    event.preventDefault();
    clipboardData.setData('text/plain', text + '\n\n本文作者：ifDo7\n本文链接：https://shgxy.github.io.git/2021/11/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/\n版权声明：本博客所有文章除特别声明外，均默认采用 CC BY-NC-SA 4.0 许可协议。');
  }
});</script></section></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/10/28/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" rel="next" title="Linux基本命令"><span class="post-nav-text">Linux基本命令</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何关于博客内容的相关讨论，欢迎前往 <a href="https://github.com/Shgxy/Shgxy.github.io/discussions" target="_blank">GitHub Discussions</a> 与我交流。</span><br></div><div id="minivaline-container"></div><script>Yun.utils.getScript("https://cdn.jsdelivr.net/npm/minivaline@6", () => {
  const minivalineConfig = {"enable":true,"serverURL":"https://waline.vercel.app","md":true,"backend":"waline"}
  minivalineConfig.el = "#minivaline-container"
  new MiniValine(minivalineConfig);
}, window.MiniValine);</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 </span><span class="with-love" id="animate" title="急！链接位招租~~"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> ifDo7</span></div><div class="live_time"><span>本博客已竭尽全力地运行了</span><span id="display_live_time"></span><span class="moe-text">啦🥰~ (●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-07-01T13:14:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="总访客量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="总访问量"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div><script>const date = new Date();
const today = (date.getMonth() + 1) + "-" + date.getDate()
const mourn_days = ["4-4"]
if (mourn_days.includes(today)) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div></body></html>